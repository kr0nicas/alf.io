# This template uses the java:8 docker image because there isn't any
# official Gradle image at this moment
#
# This is the Gradle build system for JVM applications
# https://gradle.org/
# https://github.com/gradle/gradle
image: docker:latest
image: adoptopenjdk/openjdk11:armv7l-centos-jdk11u-nightly-slim
image: gradle:jdk11

stages:
  - build
  - package
  - deploy

# Disable the Gradle daemon for Continuous Integration servers as correctness
# is usually a priority over speed in CI environments. Using a fresh
# runtime for each build is more reliable since the runtime is completely
# isolated from any previous builds.
variables:
    GRADLE_OPTS: "-Dorg.gradle.daemon=false"
    GRADLE_OPTS: "-Dorg.gradle.daemon=false"

# Make the gradle wrapper executable. This essentially downloads a copy of
# Gradle to build the project with.
# https://docs.gradle.org/current/userguide/gradle_wrapper.html
# It is expected that any modern gradle project has a wrapper

build:
  stage: build
  before_script:
    - export GRADLE_USER_HOME=`pwd`/.gradle
  script:
    - ./gradlew distribution -x test
  cache:
     key: "$CI_COMMIT_REF_NAME"
     policy: push
     paths:
         - build
         - .gradle
  artifacts:
    paths:
      - build/dockerize
    expire_in: '1 week'
  tags:
        - environment:development
package:
  stage: package
  image: docker:latest
  variables:
    # When using dind service we need to instruct docker, to talk with
    # the daemon started inside of the service. The daemon is
    # available with a network connection instead of the default
    # /var/run/docker.sock socket. docker:19.03-dind does this
    # automatically by setting the DOCKER_HOST in
    # https://github.com/docker-library/docker/blob/d45051476babc297257df490d22cbd806f1b11e4/19.03/docker-entrypoint.sh#L23-L29
    #
    # The 'docker' hostname is the alias of the service container as described at
    # https://docs.gitlab.com/ee/ci/docker/using_docker_images.html#accessing-the-services.
    #
    # Note that if you're using the Kubernetes executor, the variable should be set to
    # tcp://localhost:2376/ because of how the Kubernetes executor connects services
    # to the job container
    # DOCKER_HOST: tcp://localhost:2376/
    #
    # When using dind, it's wise to use the overlayfs driver for
    # improved performance.
    DOCKER_DRIVER: overlay2
    # Specify to Docker where to create the certificates, Docker will
    # create them automatically on boot, and will create
    # `/certs/client` that will be shared between the service and
    # build container.
    DOCKER_TLS_CERTDIR: "/certs"
  services:
    - docker:dind
  before_script:
    - echo `pwd`
    - cd build/dockerize
    - echo `ls`
  script:
    - echo `cd build`
    - docker info
    - docker build -t registry.gitlab.com/itproject41/eco-tickets .
    - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN registry.gitlab.com
    - docker push registry.gitlab.com/itproject41/eco-tickets
  tags:
        - environment:development

deploy:
  stage: deploy
  image: docker:latest
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: "/certs"
    ECO_TICKET_REGISTRY_URL: "registry.gitlab.com/itproject41/eco-tickets"
    ECO_TICKETS_NAME_CONTAINER: "eco_tickets"
    ECO_TICKETS_EXPOSE_PORT: "8080:8080"
    ECO_TICKET_NETWORK: "postgresql-ecoticket_app-tier"
    POSTGRES_PORT_5432_TCP_PORT: "5432"
    POSTGRES_PORT_5432_TCP_ADDR: "postgresql-ecoticket_postgresql"
    POSTGRES_ENV_POSTGRES_DB: "alfio"
    POSTGRES_ENV_POSTGRES_USERNAME: "postgres"
    POSTGRES_ENV_POSTGRES_PASSWORD: "password"
    SPRING_PROFILES_ACTIVE: "dev"


  services:
    - docker:dind
  before_script:
    # Install ssh-agent if not already installed, it is required by Docker.
    # (change apt-get to yum if you use a CentOS-based image)
    - 'which ssh-agent || ( apk update -y && apk install openssh-client -y )'
    # Run ssh-agent (inside the build environment)
    - eval `ssh-agent -s`
    # Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store
    #- ssh-add <(echo "$SSH_PRIVATE_KEY")
    #- echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - echo "$SSH_PRIVATE_KEY" > /tmp/gitlab_ci_ssh
    - chmod 600 /tmp/gitlab_ci_ssh
    - ssh-add /tmp/gitlab_ci_ssh
    ##
    ## Create the SSH directory and give it the right permissions
    ##
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    ##
    ## Use ssh-keyscan to scan the keys of your private server. Replace gitlab.com
    ## with your own domain name. You can copy and repeat that command if you have
    ## more than one server to connect to.
    ##
    - ssh-keyscan ${DEPLOYMENT_SERVER_IP} >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - apk upgrade && apk update
    #- apk add openssh-client
    #- apk add sshpass
    - ssh ${DEPLOYMENT_SERVER_USER}@${DEPLOYMENT_SERVER_IP} docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN registry.gitlab.com
    - ssh ${DEPLOYMENT_SERVER_USER}@${DEPLOYMENT_SERVER_IP} docker pull $ECO_TICKET_REGISTRY_URL
    - ssh ${DEPLOYMENT_SERVER_USER}@${DEPLOYMENT_SERVER_IP} "docker container stop $ECO_TICKETS_NAME_CONTAINER && docker container rm $ECO_TICKETS_NAME_CONTAINER || true"
    - ssh ${DEPLOYMENT_SERVER_USER}@${DEPLOYMENT_SERVER_IP} docker run --name $ECO_TICKETS_NAME_CONTAINER -p $ECO_TICKETS_EXPOSE_PORT --network=$ECO_TICKET_NETWORK --env POSTGRES_PORT_5432_TCP_PORT=$POSTGRES_PORT_5432_TCP_PORT --env POSTGRES_PORT_5432_TCP_ADDR=$POSTGRES_PORT_5432_TCP_ADDR --env POSTGRES_ENV_POSTGRES_DB=$POSTGRES_ENV_POSTGRES_DB --env POSTGRES_ENV_POSTGRES_USERNAME=$POSTGRES_ENV_POSTGRES_USERNAME --env POSTGRES_ENV_POSTGRES_PASSWORD=$POSTGRES_ENV_POSTGRES_PASSWORD --env SPRING_PROFILES_ACTIVE=$SPRING_PROFILES_ACTIVE -d $ECO_TICKET_REGISTRY_URL
  tags:
      - environment:development
