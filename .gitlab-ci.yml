# This template uses the java:8 docker image because there isn't any
# official Gradle image at this moment
#
stages:
  - build
  - package
# This is the Gradle build system for JVM applications
# https://gradle.org/
# https://github.com/gradle/gradle
image: adoptopenjdk/openjdk11:armv7l-centos-jdk11u-nightly-slim
image: gradle:jdk11
image: docker:latest

# Disable the Gradle daemon for Continuous Integration servers as correctness
# is usually a priority over speed in CI environments. Using a fresh
# runtime for each build is more reliable since the runtime is completely
# isolated from any previous builds.
variables:
    GRADLE_OPTS: "-Dorg.gradle.daemon=false"
    GRADLE_OPTS: "-Dorg.gradle.daemon=false"

# Make the gradle wrapper executable. This essentially downloads a copy of
# Gradle to build the project with.
# https://docs.gradle.org/current/userguide/gradle_wrapper.html
# It is expected that any modern gradle project has a wrapper
before_script:
    - echo `pwd`
    - echo `ls`
    - echo `whoami`
    #- chmod +x gradlew
    - export GRADLE_USER_HOME=`pwd`/.gradle

# We redirect the gradle user home using -g so that it caches the
# wrapper and dependencies.
# https://docs.gradle.org/current/userguide/gradle_command_line.html
#
# Unfortunately it also caches the build output so
# cleaning removes reminants of any cached builds.
# The assemble task actually builds the project.
# If it fails here, the tests can't run.
build:
    stage: build
    script:
        - ./gradlew -g /cache/.gradle clean assemble
    allow_failure: false
    script: gradle --build-cache distribution
    cache:
        key: "$CI_COMMIT_REF_NAME"
        policy: push
        paths:
            - build
            - .gradle
    tags:
       - environment:development

package:
      stage: package
      services: 
        - docker:dind
      variables:
        # When using dind service we need to instruct docker, to talk with
        # the daemon started inside of the service. The daemon is
        # available with a network connection instead of the default
        # /var/run/docker.sock socket. docker:19.03-dind does this
        # automatically by setting the DOCKER_HOST in
        # https://github.com/docker-library/docker/blob/d45051476babc297257df490d22cbd806f1b11e4/19.03/docker-entrypoint.sh#L23-L29
        #
        # The 'docker' hostname is the alias of the service container as described at
        # https://docs.gitlab.com/ee/ci/docker/using_docker_images.html#accessing-the-services.
        #
        # Note that if you're using the Kubernetes executor, the variable should be set to
        # tcp://localhost:2376/ because of how the Kubernetes executor connects services
        # to the job container
        # DOCKER_HOST: tcp://localhost:2376/
        #
        # When using dind, it's wise to use the overlayfs driver for
        # improved performance.
        DOCKER_DRIVER: overlay2
        # Specify to Docker where to create the certificates, Docker will
        # create them automatically on boot, and will create
        # `/certs/client` that will be shared between the service and
        # build container.
        DOCKER_TLS_CERTDIR: "/certs"
      script:
        - cd ./src/main/dist/
        - echo `pwd`
        - docker build -t registry.gitlab.com/itproject41/eco-tickets .
        #- docker build -t registry.gitlab.com/mathflake/api .
        - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN registry.gitlab.com
        - docker push registry.gitlab.com/itproject41/eco-tickets
      tags:
           - environment:development

# Use the generated build output to run the tests.
# test:
#     stage: test
#     script:
#         - ./gradlew -g /cache/.gradle check
#     script: gradle check
#     cache:
#         key: "$CI_COMMIT_REF_NAME"
#         policy: pull
#         paths:
#             - build
#             - .gradle
#     tags:
#         - environment:development
